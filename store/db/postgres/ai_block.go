package postgres

import (
	"context"
	"database/sql"
	"encoding/json"
	"fmt"
	"log/slog"
	"strconv"
	"strings"

	"github.com/hrygo/divinesense/internal/util"
	"github.com/hrygo/divinesense/store"
)

// txContext wraps a context with an active sql.Tx for transaction support.
type txContext struct {
	tx *sql.Tx
}

// inTransaction returns a non-nil txContext if a transaction is active in the context.
func inTransaction(ctx context.Context) *txContext {
	if tx, ok := ctx.Value(txKey{}).(*sql.Tx); ok && tx != nil {
		return &txContext{tx: tx}
	}
	return nil
}

// txKey is the context key for storing sql.Tx.
type txKey struct{}

// beginTx starts a new transaction if one is not already active.
func (d *DB) beginTx(ctx context.Context) (*sql.Tx, error) {
	if txc := inTransaction(ctx); txc != nil {
		return txc.tx, nil
	}
	return d.db.BeginTx(ctx, nil)
}

// execInTx executes a function within a transaction, committing if successful
// and rolling back on error. Returns the function's result.
func (d *DB) execInTx(ctx context.Context, fn func(*sql.Tx) error) error {
	tx, err := d.beginTx(ctx)
	if err != nil {
		return fmt.Errorf("failed to begin transaction: %w", err)
	}

	// If we're using an existing transaction, don't commit/rollback
	isNewTx := inTransaction(ctx) == nil

	if err := fn(tx); err != nil {
		if isNewTx {
			if rbErr := tx.Rollback(); rbErr != nil {
				slog.Error("Failed to rollback transaction",
					"original_error", err,
					"rollback_error", rbErr,
				)
			}
		}
		return err
	}

	if isNewTx {
		return tx.Commit()
	}
	return nil
}

// CreateAIBlock creates a new block.
//
// Optimized: round_number is auto-generated by database trigger,
// eliminating the need for a separate query.
func (d *DB) CreateAIBlock(ctx context.Context, create *store.CreateAIBlock) (*store.AIBlock, error) {
	// Generate UID if not provided
	uid := create.UID
	if uid == "" {
		uid = util.GenUUID()
	}

	// Marshal JSONB fields
	userInputsJSON, err := json.Marshal(create.UserInputs)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal user_inputs: %w", err)
	}
	// Ensure metadata is never nil - convert to empty map if needed
	// This prevents json.Marshal from producing "null" which can cause JSONB issues
	metadata := create.Metadata
	if metadata == nil {
		metadata = make(map[string]any)
	}
	metadataJSON, err := json.Marshal(metadata)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal metadata: %w", err)
	}

	// Build INSERT query dynamically based on whether parent_block_id is provided
	var parentFields string
	var parentArgs []any

	if create.ParentBlockID != nil {
		parentFields = ", parent_block_id"
		parentArgs = []any{*create.ParentBlockID}
	}

	// Build RETURNING clause dynamically
	var returningFields string
	if create.ParentBlockID != nil {
		returningFields = ", parent_block_id, branch_path"
	}

	query := `
		INSERT INTO ai_block (
			uid, conversation_id, block_type, mode,
			user_inputs, assistant_content, assistant_timestamp,
			event_stream, session_stats, cc_session_id, status, metadata` + parentFields + `
		) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12` + parentFields + `)
		RETURNING id, round_number, created_ts, updated_ts` + returningFields + `
	`

	args := []any{
		uid,
		create.ConversationID,
		string(create.BlockType),
		string(create.Mode),
		userInputsJSON,
		nil,          // assistant_content
		0,            // assistant_timestamp
		[]byte("[]"), // event_stream
		nil,          // session_stats
		create.CCSessionID,
		string(create.Status),
		metadataJSON,
	}
	args = append(args, parentArgs...)

	var block store.AIBlock

	// Scan based on whether parent fields were requested
	if create.ParentBlockID != nil {
		var parentBlockID sql.NullInt64
		var branchPath sql.NullString
		err = d.db.QueryRowContext(ctx, query, args...).Scan(
			&block.ID, &block.RoundNumber, &block.CreatedTs, &block.UpdatedTs,
			&parentBlockID, &branchPath,
		)
		if parentBlockID.Valid {
			block.ParentBlockID = &parentBlockID.Int64
		}
		if branchPath.Valid {
			block.BranchPath = branchPath.String
		}
	} else {
		err = d.db.QueryRowContext(ctx, query, args...).Scan(
			&block.ID, &block.RoundNumber, &block.CreatedTs, &block.UpdatedTs,
		)
	}

	if err != nil {
		return nil, fmt.Errorf("failed to create ai_block: %w", err)
	}

	// Set remaining fields
	block.UID = uid
	block.ConversationID = create.ConversationID
	block.BlockType = create.BlockType
	block.Mode = create.Mode
	block.UserInputs = create.UserInputs
	block.EventStream = []store.BlockEvent{}
	block.Status = create.Status
	block.Metadata = create.Metadata

	return &block, nil
}

// GetAIBlock retrieves a block by ID
func (d *DB) GetAIBlock(ctx context.Context, id int64) (*store.AIBlock, error) {
	query := `
		SELECT id, uid, conversation_id, round_number, block_type, mode,
		       user_inputs, assistant_content, assistant_timestamp,
		       event_stream, session_stats, cc_session_id, status, metadata,
		       created_ts, updated_ts, parent_block_id, branch_path,
		       token_usage, cost_estimate, model_version, user_feedback,
		       regeneration_count, error_message, archived_at
		FROM ai_block
		WHERE id = $1
	`

	var block store.AIBlock
	var userInputsJSON, eventStreamJSON, sessionStatsJSON, metadataJSON []byte
	var tokenUsageJSON []byte
	var assistantContent sql.NullString
	var assistantTimestamp sql.NullInt64
	var ccSessionID sql.NullString
	var parentBlockID sql.NullInt64
	var branchPath sql.NullString
	// New fields for block extensions (ai-block-fields-extension)
	var costEstimate sql.NullInt64
	var modelVersion sql.NullString
	var userFeedback sql.NullString
	var regenerationCount sql.NullInt32
	var errorMessage sql.NullString
	var archivedAt sql.NullInt64

	err := d.db.QueryRowContext(ctx, query, id).Scan(
		&block.ID,
		&block.UID,
		&block.ConversationID,
		&block.RoundNumber,
		&block.BlockType,
		&block.Mode,
		&userInputsJSON,
		&assistantContent,
		&assistantTimestamp,
		&eventStreamJSON,
		&sessionStatsJSON,
		&ccSessionID,
		&block.Status,
		&metadataJSON,
		&block.CreatedTs,
		&block.UpdatedTs,
		&parentBlockID,
		&branchPath,
		&tokenUsageJSON,
		&costEstimate,
		&modelVersion,
		&userFeedback,
		&regenerationCount,
		&errorMessage,
		&archivedAt,
	)

	if err != nil {
		return nil, fmt.Errorf("failed to get ai_block: %w", err)
	}

	// Unmarshal JSONB fields
	if err := json.Unmarshal(userInputsJSON, &block.UserInputs); err != nil {
		return nil, fmt.Errorf("failed to unmarshal user_inputs: %w", err)
	}
	if err := json.Unmarshal(eventStreamJSON, &block.EventStream); err != nil {
		return nil, fmt.Errorf("failed to unmarshal event_stream: %w", err)
	}
	if err := json.Unmarshal(metadataJSON, &block.Metadata); err != nil {
		return nil, fmt.Errorf("failed to unmarshal metadata: %w", err)
	}
	if assistantContent.Valid {
		block.AssistantContent = assistantContent.String
	}
	if assistantTimestamp.Valid {
		block.AssistantTimestamp = assistantTimestamp.Int64
	}
	if ccSessionID.Valid {
		block.CCSessionID = ccSessionID.String
	}
	if parentBlockID.Valid {
		block.ParentBlockID = &parentBlockID.Int64
	}
	if branchPath.Valid {
		block.BranchPath = branchPath.String
	}
	// Parse nullable token_usage JSONB (P1-A006)
	if tokenUsageJSON != nil {
		var usage store.TokenUsage
		if err := json.Unmarshal(tokenUsageJSON, &usage); err == nil {
			block.TokenUsage = &usage
		}
	}
	// Parse new fields (ai-block-fields-extension)
	if costEstimate.Valid {
		block.CostEstimate = costEstimate.Int64
	}
	if modelVersion.Valid {
		block.ModelVersion = modelVersion.String
	}
	if userFeedback.Valid {
		block.UserFeedback = userFeedback.String
	}
	if regenerationCount.Valid {
		block.RegenerationCount = regenerationCount.Int32
	}
	if errorMessage.Valid {
		block.ErrorMessage = errorMessage.String
	}
	if archivedAt.Valid {
		block.ArchivedAt = &archivedAt.Int64
	}
	// Parse nullable session_stats JSONB
	if sessionStatsJSON != nil {
		var stats store.SessionStats
		if err := json.Unmarshal(sessionStatsJSON, &stats); err == nil {
			block.SessionStats = &stats
		}
	}

	return &block, nil
}

// ListAIBlocks retrieves blocks for a conversation
func (d *DB) ListAIBlocks(ctx context.Context, find *store.FindAIBlock) ([]*store.AIBlock, error) {
	where, args := []string{"1 = 1"}, []any{} // Fixed: Initialize empty slice, not []any{1}

	if find.ID != nil {
		where, args = append(where, "id = "+placeholder(len(args)+1)), append(args, *find.ID)
	}
	if find.UID != nil {
		where, args = append(where, "uid = "+placeholder(len(args)+1)), append(args, *find.UID)
	}
	if find.ConversationID != nil {
		where, args = append(where, "conversation_id = "+placeholder(len(args)+1)), append(args, *find.ConversationID)
	}
	if find.Status != nil {
		where, args = append(where, "status = "+placeholder(len(args)+1)), append(args, string(*find.Status))
	}
	if find.Mode != nil {
		where, args = append(where, "mode = "+placeholder(len(args)+1)), append(args, string(*find.Mode))
	}
	if find.CCSessionID != nil {
		where, args = append(where, "cc_session_id = "+placeholder(len(args)+1)), append(args, *find.CCSessionID)
	}
	if find.ParentBlockID != nil {
		where, args = append(where, "parent_block_id = "+placeholder(len(args)+1)), append(args, *find.ParentBlockID)
	}

	query := `
		SELECT id, uid, conversation_id, round_number, block_type, mode,
		       user_inputs, assistant_content, assistant_timestamp,
		       event_stream, session_stats, cc_session_id, status, metadata,
		       created_ts, updated_ts, parent_block_id, branch_path,
		       token_usage, cost_estimate, model_version, user_feedback,
		       regeneration_count, error_message, archived_at
		FROM ai_block
		WHERE ` + strings.Join(where, " AND ") + `
		ORDER BY round_number ASC
	`

	rows, err := d.db.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, fmt.Errorf("failed to list ai_blocks: %w", err)
	}
	defer rows.Close()

	list := make([]*store.AIBlock, 0)
	for rows.Next() {
		block, err := scanAIBlock(rows)
		if err != nil {
			return nil, fmt.Errorf("failed to scan ai_block: %w", err)
		}
		list = append(list, block)
	}

	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("failed to iterate ai_blocks: %w", err)
	}

	return list, nil
}

// UpdateAIBlock updates a block
func (d *DB) UpdateAIBlock(ctx context.Context, update *store.UpdateAIBlock) (*store.AIBlock, error) {
	set, args := []string{}, []any{}

	if update.UserInputs != nil {
		userInputsJSON, err := json.Marshal(*update.UserInputs)
		if err != nil {
			return nil, fmt.Errorf("failed to marshal user_inputs: %w", err)
		}
		set, args = append(set, "user_inputs = "+placeholder(len(args)+1)), append(args, userInputsJSON)
	}
	if update.AssistantContent != nil {
		set, args = append(set, "assistant_content = "+placeholder(len(args)+1)), append(args, *update.AssistantContent)
	}
	if update.AssistantTs != nil {
		set, args = append(set, "assistant_timestamp = "+placeholder(len(args)+1)), append(args, *update.AssistantTs)
	}
	if update.EventStream != nil {
		eventStreamJSON, err := json.Marshal(*update.EventStream)
		if err != nil {
			return nil, fmt.Errorf("failed to marshal event_stream: %w", err)
		}
		set, args = append(set, "event_stream = "+placeholder(len(args)+1)), append(args, eventStreamJSON)
	}
	if update.SessionStats != nil {
		sessionStatsJSON, err := json.Marshal(update.SessionStats)
		if err != nil {
			return nil, fmt.Errorf("failed to marshal session_stats: %w", err)
		}
		set, args = append(set, "session_stats = "+placeholder(len(args)+1)), append(args, sessionStatsJSON)
	}
	if update.CCSessionID != nil {
		set, args = append(set, "cc_session_id = "+placeholder(len(args)+1)), append(args, *update.CCSessionID)
	}
	if update.Status != nil {
		set, args = append(set, "status = "+placeholder(len(args)+1)), append(args, string(*update.Status))
	}
	if update.UpdatedTs != nil {
		set, args = append(set, "updated_ts = "+placeholder(len(args)+1)), append(args, *update.UpdatedTs)
	}
	// Update new fields (ai-block-fields-extension)
	if update.TokenUsage != nil {
		tokenUsageJSON, err := json.Marshal(update.TokenUsage)
		if err != nil {
			return nil, fmt.Errorf("failed to marshal token_usage: %w", err)
		}
		set, args = append(set, "token_usage = "+placeholder(len(args)+1)), append(args, tokenUsageJSON)
	}
	if update.CostEstimate != nil {
		set, args = append(set, "cost_estimate = "+placeholder(len(args)+1)), append(args, *update.CostEstimate)
	}
	if update.ModelVersion != nil {
		set, args = append(set, "model_version = "+placeholder(len(args)+1)), append(args, *update.ModelVersion)
	}
	if update.UserFeedback != nil {
		set, args = append(set, "user_feedback = "+placeholder(len(args)+1)), append(args, *update.UserFeedback)
	}
	if update.RegenerationCount != nil {
		set, args = append(set, "regeneration_count = "+placeholder(len(args)+1)), append(args, *update.RegenerationCount)
	}
	if update.ErrorMessage != nil {
		set, args = append(set, "error_message = "+placeholder(len(args)+1)), append(args, *update.ErrorMessage)
	}
	if update.ArchivedAt != nil {
		set, args = append(set, "archived_at = "+placeholder(len(args)+1)), append(args, *update.ArchivedAt)
	}

	if len(set) == 0 {
		return d.GetAIBlock(ctx, update.ID)
	}

	// Merge metadata (needs to be JSON encoded for JSONB column)
	// Ensure metadata is never nil - convert to empty map if needed
	// This prevents json.Marshal from producing "null" which can cause issues
	metadata := update.Metadata
	if metadata == nil {
		metadata = make(map[string]any)
	}
	metadataJSON, err := json.Marshal(metadata)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal metadata: %w", err)
	}
	set, args = append(set, "metadata = metadata || "+placeholder(len(args)+1)+"::jsonb"), append(args, metadataJSON)

	args = append(args, update.ID)

	query := `UPDATE ai_block SET ` + strings.Join(set, ", ") + ` WHERE id = ` + placeholder(len(args))

	if _, err := d.db.ExecContext(ctx, query, args...); err != nil {
		return nil, fmt.Errorf("failed to update ai_block: %w", err)
	}

	return d.GetAIBlock(ctx, update.ID)
}

// AppendUserInput appends a user input to an existing block
func (d *DB) AppendUserInput(ctx context.Context, blockID int64, input store.UserInput) error {
	query := `
		UPDATE ai_block
		SET user_inputs = user_inputs || $1::jsonb,
		    updated_ts = EXTRACT(EPOCH FROM NOW()) * 1000::BIGINT
		WHERE id = $2
	`

	inputJSON, err := json.Marshal([]store.UserInput{input})
	if err != nil {
		return fmt.Errorf("failed to marshal user input: %w", err)
	}

	result, err := d.db.ExecContext(ctx, query, inputJSON, blockID)
	if err != nil {
		return fmt.Errorf("failed to append user input: %w", err)
	}

	rows, err := result.RowsAffected()
	if err != nil {
		return fmt.Errorf("failed to get rows affected: %w", err)
	}
	if rows == 0 {
		return fmt.Errorf("block not found: %d", blockID)
	}

	slog.Debug("Appended user input to block",
		"block_id", blockID,
		"content_length", len(input.Content),
	)

	return nil
}

// AppendEvent appends an event to the event stream
func (d *DB) AppendEvent(ctx context.Context, blockID int64, event store.BlockEvent) error {
	query := `
		UPDATE ai_block
		SET event_stream = event_stream || $1::jsonb,
		    updated_ts = EXTRACT(EPOCH FROM NOW()) * 1000::BIGINT
		WHERE id = $2
	`

	eventJSON, err := json.Marshal([]store.BlockEvent{event})
	if err != nil {
		return fmt.Errorf("failed to marshal event: %w", err)
	}

	result, err := d.db.ExecContext(ctx, query, eventJSON, blockID)
	if err != nil {
		return fmt.Errorf("failed to append event: %w", err)
	}

	rows, err := result.RowsAffected()
	if err != nil {
		return fmt.Errorf("failed to get rows affected: %w", err)
	}
	if rows == 0 {
		return fmt.Errorf("block not found: %d", blockID)
	}

	slog.Debug("Appended event to block",
		"block_id", blockID,
		"event_type", event.Type,
	)

	return nil
}

// AppendEventsBatch appends multiple events to the event stream in a single query.
//
// This is more efficient than calling AppendEvent multiple times,
// especially for streaming responses with many events.
func (d *DB) AppendEventsBatch(ctx context.Context, blockID int64, events []store.BlockEvent) error {
	if len(events) == 0 {
		return nil
	}

	eventsJSON, err := json.Marshal(events)
	if err != nil {
		return fmt.Errorf("failed to marshal events: %w", err)
	}

	query := `
		UPDATE ai_block
		SET event_stream = event_stream || $1::jsonb,
		    updated_ts = EXTRACT(EPOCH FROM NOW()) * 1000::BIGINT
		WHERE id = $2
	`

	result, err := d.db.ExecContext(ctx, query, eventsJSON, blockID)
	if err != nil {
		return fmt.Errorf("failed to append events batch: %w", err)
	}

	rows, err := result.RowsAffected()
	if err != nil {
		return fmt.Errorf("failed to get rows affected: %w", err)
	}
	if rows == 0 {
		return fmt.Errorf("block not found: %d", blockID)
	}

	slog.Debug("Appended events batch to block",
		"block_id", blockID,
		"event_count", len(events),
	)

	return nil
}

// UpdateAIBlockStatus updates the block status
func (d *DB) UpdateAIBlockStatus(ctx context.Context, blockID int64, status store.AIBlockStatus) error {
	query := `
		UPDATE ai_block
		SET status = $1,
		    updated_ts = EXTRACT(EPOCH FROM NOW()) * 1000::BIGINT
		WHERE id = $2
	`

	result, err := d.db.ExecContext(ctx, query, string(status), blockID)
	if err != nil {
		return fmt.Errorf("failed to update block status: %w", err)
	}

	rows, err := result.RowsAffected()
	if err != nil {
		return fmt.Errorf("failed to get rows affected: %w", err)
	}
	if rows == 0 {
		return fmt.Errorf("block not found: %d", blockID)
	}

	slog.Debug("Updated block status",
		"block_id", blockID,
		"status", status,
	)

	return nil
}

// DeleteAIBlock deletes a block
func (d *DB) DeleteAIBlock(ctx context.Context, id int64) error {
	query := `DELETE FROM ai_block WHERE id = $1`

	result, err := d.db.ExecContext(ctx, query, id)
	if err != nil {
		return fmt.Errorf("failed to delete ai_block: %w", err)
	}

	rows, err := result.RowsAffected()
	if err != nil {
		return fmt.Errorf("failed to get rows affected: %w", err)
	}
	if rows == 0 {
		return fmt.Errorf("block not found: %d", id)
	}

	return nil
}

// GetLatestAIBlock retrieves the latest block for a conversation
func (d *DB) GetLatestAIBlock(ctx context.Context, conversationID int32) (*store.AIBlock, error) {
	query := `
		SELECT id, uid, conversation_id, round_number, block_type, mode,
		       user_inputs, assistant_content, assistant_timestamp,
		       event_stream, session_stats, cc_session_id, status, metadata,
		       created_ts, updated_ts, parent_block_id, branch_path,
		       token_usage, cost_estimate, model_version, user_feedback,
		       regeneration_count, error_message, archived_at
		FROM ai_block
		WHERE conversation_id = $1
		ORDER BY round_number DESC
		LIMIT 1
	`

	rows, err := d.db.QueryContext(ctx, query, conversationID)
	if err != nil {
		return nil, fmt.Errorf("failed to get latest ai_block: %w", err)
	}
	defer rows.Close()

	if !rows.Next() {
		return nil, nil // No block found
	}

	block, err := scanAIBlock(rows)
	if err != nil {
		return nil, fmt.Errorf("failed to scan ai_block: %w", err)
	}

	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("failed to iterate ai_block: %w", err)
	}

	return block, nil
}

// GetPendingAIBlocks retrieves all pending/streaming blocks for cleanup
func (d *DB) GetPendingAIBlocks(ctx context.Context) ([]*store.AIBlock, error) {
	query := `
		SELECT id, uid, conversation_id, round_number, block_type, mode,
		       user_inputs, assistant_content, assistant_timestamp,
		       event_stream, session_stats, cc_session_id, status, metadata,
		       created_ts, updated_ts, parent_block_id, branch_path,
		       token_usage, cost_estimate, model_version, user_feedback,
		       regeneration_count, error_message, archived_at
		FROM ai_block
		WHERE status IN ('pending', 'streaming')
		ORDER BY created_ts ASC
	`

	rows, err := d.db.QueryContext(ctx, query)
	if err != nil {
		return nil, fmt.Errorf("failed to get pending ai_blocks: %w", err)
	}
	defer rows.Close()

	list := make([]*store.AIBlock, 0)
	for rows.Next() {
		block, err := scanAIBlock(rows)
		if err != nil {
			return nil, fmt.Errorf("failed to scan ai_block: %w", err)
		}
		list = append(list, block)
	}

	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("failed to iterate ai_blocks: %w", err)
	}

	return list, nil
}

// CompleteBlock atomically marks a block as completed with assistant content and session stats.
//
// This method ensures atomicity by using a transaction to update both the status,
// assistant content, and session stats together.
func (d *DB) CompleteBlock(
	ctx context.Context,
	blockID int64,
	assistantContent string,
	sessionStats *store.SessionStats,
) error {
	return d.execInTx(ctx, func(tx *sql.Tx) error {
		// Marshal session stats if provided
		var sessionStatsJSON []byte
		var err error
		if sessionStats != nil {
			sessionStatsJSON, err = json.Marshal(sessionStats)
			if err != nil {
				return fmt.Errorf("failed to marshal session_stats: %w", err)
			}
		}

		query := `
			UPDATE ai_block
			SET status = $1,
			    assistant_content = $2,
			    session_stats = $3,
			    updated_ts = EXTRACT(EPOCH FROM NOW()) * 1000::BIGINT
			WHERE id = $4
		`

		result, err := tx.ExecContext(ctx, query,
			store.AIBlockStatusCompleted,
			assistantContent,
			sessionStatsJSON,
			blockID,
		)
		if err != nil {
			return fmt.Errorf("failed to complete block: %w", err)
		}

		rows, err := result.RowsAffected()
		if err != nil {
			return fmt.Errorf("failed to get rows affected: %w", err)
		}
		if rows == 0 {
			return fmt.Errorf("block not found: %d", blockID)
		}

		slog.Info("Completed block transactionally",
			"block_id", blockID,
		)

		return nil
	})
}

// scanAIBlock scans a row into an AIBlock
func scanAIBlock(rows *sql.Rows) (*store.AIBlock, error) {
	var block store.AIBlock
	var userInputsJSON, eventStreamJSON, sessionStatsJSON, metadataJSON []byte
	var tokenUsageJSON []byte
	var assistantContent sql.NullString
	var assistantTimestamp sql.NullInt64
	var ccSessionID sql.NullString
	var parentBlockID sql.NullInt64
	var branchPath sql.NullString
	// New fields for block extensions (ai-block-fields-extension)
	var costEstimate sql.NullInt64
	var modelVersion sql.NullString
	var userFeedback sql.NullString
	var regenerationCount sql.NullInt32
	var errorMessage sql.NullString
	var archivedAt sql.NullInt64

	err := rows.Scan(
		&block.ID,
		&block.UID,
		&block.ConversationID,
		&block.RoundNumber,
		&block.BlockType,
		&block.Mode,
		&userInputsJSON,
		&assistantContent,
		&assistantTimestamp,
		&eventStreamJSON,
		&sessionStatsJSON,
		&ccSessionID,
		&block.Status,
		&metadataJSON,
		&block.CreatedTs,
		&block.UpdatedTs,
		&parentBlockID,
		&branchPath,
		&tokenUsageJSON,
		&costEstimate,
		&modelVersion,
		&userFeedback,
		&regenerationCount,
		&errorMessage,
		&archivedAt,
	)

	if err != nil {
		return nil, err
	}

	// Unmarshal JSONB fields
	if err := json.Unmarshal(userInputsJSON, &block.UserInputs); err != nil {
		return nil, fmt.Errorf("failed to unmarshal user_inputs: %w", err)
	}
	if err := json.Unmarshal(eventStreamJSON, &block.EventStream); err != nil {
		return nil, fmt.Errorf("failed to unmarshal event_stream: %w", err)
	}
	if err := json.Unmarshal(metadataJSON, &block.Metadata); err != nil {
		return nil, fmt.Errorf("failed to unmarshal metadata: %w", err)
	}
	if assistantContent.Valid {
		block.AssistantContent = assistantContent.String
	}
	if assistantTimestamp.Valid {
		block.AssistantTimestamp = assistantTimestamp.Int64
	}
	if ccSessionID.Valid {
		block.CCSessionID = ccSessionID.String
	}
	if parentBlockID.Valid {
		block.ParentBlockID = &parentBlockID.Int64
	}
	if branchPath.Valid {
		block.BranchPath = branchPath.String
	}
	// Parse nullable token_usage JSONB (P1-A006)
	if tokenUsageJSON != nil {
		var usage store.TokenUsage
		if err := json.Unmarshal(tokenUsageJSON, &usage); err == nil {
			block.TokenUsage = &usage
		}
	}
	// Parse new fields (ai-block-fields-extension)
	if costEstimate.Valid {
		block.CostEstimate = costEstimate.Int64
	}
	if modelVersion.Valid {
		block.ModelVersion = modelVersion.String
	}
	if userFeedback.Valid {
		block.UserFeedback = userFeedback.String
	}
	if regenerationCount.Valid {
		block.RegenerationCount = regenerationCount.Int32
	}
	if errorMessage.Valid {
		block.ErrorMessage = errorMessage.String
	}
	if archivedAt.Valid {
		block.ArchivedAt = &archivedAt.Int64
	}
	// Parse nullable session_stats JSONB
	if sessionStatsJSON != nil {
		var stats store.SessionStats
		if err := json.Unmarshal(sessionStatsJSON, &stats); err == nil {
			block.SessionStats = &stats
		}
	}

	return &block, nil
}

// CreateAIBlockWithRound creates a block with auto-incremented round number..
//
// Optimized: Uses database trigger for round_number, eliminating the separate
// getNextRoundNumber query. This function now delegates to CreateAIBlock.
func (d *DB) CreateAIBlockWithRound(ctx context.Context, create *store.CreateAIBlock) (*store.AIBlock, error) {
	return d.CreateAIBlock(ctx, create)
}

// ForkBlock creates a new block as a branch from an existing block.
// The new block inherits the parent's conversation. User inputs can be optionally replaced.
//
// Parameters:
//   - parentID: ID of the parent block to fork from
//   - reason: Reason for forking (e.g., "user_fork", "User edited message: ...")
//   - replaceUserInputs: If non-nil, replaces parent's user inputs. If nil or empty, inherits from parent.
//
// The fork reason is stored in metadata for debugging and audit trail.
// (tree-conversation-branching spec)
func (d *DB) ForkBlock(ctx context.Context, parentID int64, reason string, replaceUserInputs []store.UserInput) (*store.AIBlock, error) {
	// Validate reason parameter
	if reason == "" {
		return nil, fmt.Errorf("fork reason cannot be empty")
	}

	// First, get the parent block
	parent, err := d.GetAIBlock(ctx, parentID)
	if err != nil {
		return nil, fmt.Errorf("failed to get parent block: %w", err)
	}
	if parent == nil {
		return nil, fmt.Errorf("parent block not found: %d", parentID)
	}

	// Determine which user inputs to use
	// - Explicitly provided (non-nil, non-empty) → use replacements (user is editing)
	// - Nil or empty array → inherit from parent (user is just branching)
	userInputs := parent.UserInputs
	if replaceUserInputs != nil && len(replaceUserInputs) > 0 {
		userInputs = replaceUserInputs
	}

	// Prepare metadata: inherit parent's metadata and add fork reason
	metadata := make(map[string]any)
	for k, v := range parent.Metadata {
		metadata[k] = v
	}
	metadata["forked_from"] = parentID
	metadata["fork_reason"] = reason
	if replaceUserInputs != nil && len(replaceUserInputs) > 0 {
		metadata["fork_type"] = "edit"
	} else {
		metadata["fork_type"] = "branch"
	}

	// Create a new block with the parent's conversation ID and user inputs
	// The database trigger will auto-generate the branch_path based on parent_block_id
	uid := util.GenUUID()
	userInputsJSON, err := json.Marshal(userInputs)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal user_inputs: %w", err)
	}
	metadataJSON, err := json.Marshal(metadata)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal metadata: %w", err)
	}

	query := `
		INSERT INTO ai_block (
			uid, conversation_id, block_type, mode,
			user_inputs, assistant_content, assistant_timestamp,
			event_stream, session_stats, cc_session_id, status, metadata,
			parent_block_id
		) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)
		RETURNING id, round_number, branch_path, created_ts, updated_ts
	`

	var block store.AIBlock
	var branchPath sql.NullString

	err = d.db.QueryRowContext(ctx, query,
		uid,
		parent.ConversationID,
		string(parent.BlockType),
		string(parent.Mode),
		userInputsJSON,
		nil,          // assistant_content - empty initially
		0,            // assistant_timestamp
		[]byte("[]"), // event_stream
		nil,          // session_stats
		"",           // cc_session_id - not inherited
		store.AIBlockStatusPending,
		metadataJSON,
		parentID,
	).Scan(
		&block.ID,
		&block.RoundNumber,
		&branchPath,
		&block.CreatedTs,
		&block.UpdatedTs,
	)

	if err != nil {
		return nil, fmt.Errorf("failed to fork block: %w", err)
	}

	// Set remaining fields
	block.UID = uid
	block.ConversationID = parent.ConversationID
	block.BlockType = parent.BlockType
	block.Mode = parent.Mode
	block.UserInputs = userInputs
	block.EventStream = []store.BlockEvent{}
	block.Status = store.AIBlockStatusPending
	block.Metadata = metadata
	block.ParentBlockID = &parentID
	if branchPath.Valid {
		block.BranchPath = branchPath.String
	}

	// Note: Logging is done at the service layer (ai_service_block.go)
	// to avoid duplicate log entries and provide more context (user_id).

	return &block, nil
}

// ListChildBlocks lists all direct children of a block.
// (tree-conversation-branching spec)
func (d *DB) ListChildBlocks(ctx context.Context, parentID int64) ([]*store.AIBlock, error) {
	query := `
		SELECT id, uid, conversation_id, round_number, block_type, mode,
		       user_inputs, assistant_content, assistant_timestamp,
		       event_stream, session_stats, cc_session_id, status, metadata,
		       created_ts, updated_ts, parent_block_id, branch_path,
		       token_usage, cost_estimate, model_version, user_feedback,
		       regeneration_count, error_message, archived_at
		FROM ai_block
		WHERE parent_block_id = $1
		ORDER BY round_number ASC
	`

	rows, err := d.db.QueryContext(ctx, query, parentID)
	if err != nil {
		return nil, fmt.Errorf("failed to list child blocks: %w", err)
	}
	defer rows.Close()

	list := make([]*store.AIBlock, 0)
	for rows.Next() {
		block, err := scanAIBlock(rows)
		if err != nil {
			return nil, fmt.Errorf("failed to scan child block: %w", err)
		}
		list = append(list, block)
	}

	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("failed to iterate child blocks: %w", err)
	}

	return list, nil
}

// GetActivePath retrieves the currently active branch path for a conversation.
// Returns blocks ordered by branch_path to show the active conversation flow.
// (tree-conversation-branching spec)
func (d *DB) GetActivePath(ctx context.Context, conversationID int32) ([]*store.AIBlock, error) {
	// Query blocks that are not archived (active blocks)
	// and order by round_number to get the conversation flow
	query := `
		SELECT id, uid, conversation_id, round_number, block_type, mode,
		       user_inputs, assistant_content, assistant_timestamp,
		       event_stream, session_stats, cc_session_id, status, metadata,
		       created_ts, updated_ts, parent_block_id, branch_path,
		       token_usage, cost_estimate, model_version, user_feedback,
		       regeneration_count, error_message, archived_at
		FROM ai_block
		WHERE conversation_id = $1 AND archived_at IS NULL
		ORDER BY round_number ASC
	`

	rows, err := d.db.QueryContext(ctx, query, conversationID)
	if err != nil {
		return nil, fmt.Errorf("failed to get active path: %w", err)
	}
	defer rows.Close()

	path := make([]*store.AIBlock, 0)
	for rows.Next() {
		block, err := scanAIBlock(rows)
		if err != nil {
			return nil, fmt.Errorf("failed to scan block in path: %w", err)
		}
		path = append(path, block)
	}

	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("failed to iterate active path: %w", err)
	}

	return path, nil
}

// DeleteBranch deletes a block and all its descendants.
// If cascade is true, recursively delete all descendants.
// If cascade is false, only delete the specified block.
// (tree-conversation-branching spec)
func (d *DB) DeleteBranch(ctx context.Context, blockID int64, cascade bool) error {
	if cascade {
		// Recursive delete: delete all descendants first
		// First, find all children
		children, err := d.ListChildBlocks(ctx, blockID)
		if err != nil {
			return fmt.Errorf("failed to list children for cascade delete: %w", err)
		}

		// Recursively delete each child branch
		for _, child := range children {
			if err := d.DeleteBranch(ctx, child.ID, true); err != nil {
				return fmt.Errorf("failed to delete child branch %d: %w", child.ID, err)
			}
		}
	}

	// Delete the block itself
	query := `DELETE FROM ai_block WHERE id = $1`
	result, err := d.db.ExecContext(ctx, query, blockID)
	if err != nil {
		return fmt.Errorf("failed to delete block: %w", err)
	}

	rows, err := result.RowsAffected()
	if err != nil {
		return fmt.Errorf("failed to get rows affected: %w", err)
	}
	if rows == 0 {
		return fmt.Errorf("block not found: %d", blockID)
	}

	slog.Info("Deleted branch",
		"block_id", blockID,
		"cascade", cascade,
	)

	return nil
}

// ArchiveInactiveBranches archives blocks not on the active branch path.
// Sets archived_at timestamp for blocks that don't match the target path.
// The target path format is "0/1/3" where each number is a branch index.
// (tree-conversation-branching spec)
func (d *DB) ArchiveInactiveBranches(ctx context.Context, conversationID int32, targetPath string, archivedAt int64) error {
	// Get all blocks for this conversation
	blocks, err := d.ListAIBlocks(ctx, &store.FindAIBlock{
		ConversationID: &conversationID,
	})
	if err != nil {
		return fmt.Errorf("failed to list blocks: %w", err)
	}

	// Parse target path into segments for comparison
	targetSegments := parseBranchPath(targetPath)

	// Archive blocks that are not on the target path
	for _, block := range blocks {
		// Skip already archived blocks
		if block.ArchivedAt != nil {
			continue
		}

		// Check if this block's path is on the target path
		blockSegments := parseBranchPath(block.BranchPath)

		// A block is on the target path if its path is a prefix of target path
		// or if target path starts with block's path
		if !isPathOnActiveBranch(blockSegments, targetSegments) {
			// Archive this block
			query := `UPDATE ai_block SET archived_at = $1, updated_ts = $2 WHERE id = $3`
			_, err := d.db.ExecContext(ctx, query, archivedAt, archivedAt, block.ID)
			if err != nil {
				return fmt.Errorf("failed to archive block %d: %w", block.ID, err)
			}
			slog.Debug("Archived inactive branch block",
				"block_id", block.ID,
				"branch_path", block.BranchPath,
				"target_path", targetPath,
			)
		}
	}

	slog.Info("Archived inactive branches",
		"conversation_id", conversationID,
		"target_path", targetPath,
		"archived_at", archivedAt,
	)

	return nil
}

// parseBranchPath parses a branch path string into segments.
func parseBranchPath(path string) []int {
	if path == "" {
		return []int{}
	}

	parts := strings.Split(path, "/")
	segments := make([]int, 0, len(parts))
	for _, p := range parts {
		if num, err := strconv.Atoi(p); err == nil {
			segments = append(segments, num)
		}
	}
	return segments
}

// isPathOnActiveBranch checks if a block's path is on the active branch.
// A block is on the active branch if its path is a prefix of the active path
// or if the active path starts with the block's path.
func isPathOnActiveBranch(blockPath, activePath []int) bool {
	// If either is empty, consider it on the path
	if len(blockPath) == 0 || len(activePath) == 0 {
		return true
	}

	// Block is on active path if it's a prefix of active path
	if len(blockPath) <= len(activePath) {
		for i := 0; i < len(blockPath); i++ {
			if blockPath[i] != activePath[i] {
				return false
			}
		}
		return true
	}

	// Also check if active path is a prefix of block path
	// (for blocks that are descendants of the active path)
	if len(activePath) < len(blockPath) {
		for i := 0; i < len(activePath); i++ {
			if activePath[i] != blockPath[i] {
				return false
			}
		}
		return true
	}

	return false
}
