# 洞察报告模板

> 产品洞察的最终产出物：从理解到洞察到行动

---

## 报告结构

```
┌─────────────────────────────────────────────────────────────┐
│  1. 执行摘要              (TL;DR，3-5 条核心结论)        │
│  2. 问题本质分析          (用户痛点，矛盾核心)            │
│  3. 价值溯源              (为什么成功)                      │
│  4. 模式抽象              (可迁移的设计模式)              │
│  5. 战略建议              (做/不做/差异化)                │
│  6. 实施任务              (仅当确定要做时)              │
└─────────────────────────────────────────────────────────────┘
```

---

## 1. 执行摘要

### 核心发现

| 发现 | 说明 |
|:-----|:-----|
| **分析范围** | OpenClaw + 对标竞品（可选） |
| **核心洞察** | 一句话总结最重要的发现 |
| **战略建议** | 做 / 不做 / 差异化的核心建议 |
| **优先行动** | 1-2 个最重要的事项 |

### 示例

```markdown
## 执行摘要

| 维度 | 发现 |
|:-----|:-----|
| **分析对象** | OpenClaw 会话修剪功能 |
| **核心洞察** | 这不是"修剪"，而是"记忆成本管理"模式 |
| **战略建议** | **不做**竞品的时间修剪，**做**语义相关性检索 |
| **优先行动** | P0: 本地记忆索引优化 |

**一句话总结**：
OpenClaw 的会话修剪本质是成本优化策略，
而我们有机会通过本地化优势实现更好的语义相关性管理。
```

---

## 2. 问题本质分析

### 用户痛点

```
核心矛盾：____________ vs _____________

具体表现：
• 用户遭遇的困扰
• 限制因素有哪些
• 当前方案的不足
```

### 问题本质

```
这不仅是"功能 X"，而是【_______模式】

本质矛盾：
• A: ___________
• B: ___________
• 解决方式：_______
```

### 示例

```markdown
## 问题本质

**核心矛盾**：AI 记忆的无限增长 vs 有限资源

具体表现：
• API 调用成本随对话历史线性增长
• 上下文窗口限制导致检索质量下降
• 用户感知：越用越贵，越用越慢

**问题本质**：
这不仅是"会话修剪"，而是【记忆成本管理】模式

本质矛盾：
• A: 保留完整记忆 → 高成本
• B: 修剪对话 → 丢失信息
• 解决方式：智能提取高价值信息
```

---

## 3. 价值溯源

### 用户价值来源

```
主要价值：________ (用户最关心的)

次要价值：________ (附加收益)

用户证据：
• Issue 讨论: "..."
• Release Notes: "..."
• 用户评价: "..."
```

### 成功要素

```
技术要素：
• ___________

设计要素：
• ___________

时机要素：
• ___________
```

### 示例

```markdown
## 价值溯源

### 用户价值来源

**主要价值**：成本控制（API 调用费用）
- 用户讨论："每月节省 $XX"
- Release 强调："降低 50% API 调用"

**次要价值**：响应速度（更少上下文）
- 用户反馈："明显更快了"

### 成功要素

**技术要素**：
- 结构化摘要提取
- 用户可控的修剪策略

**设计要素**：
- 默认智能策略
- 高级用户可定制

**时机要素**：
- AI 普及后成本问题凸显
- 用户对 AI 成本敏感度提高
```

---

## 4. 模式抽象

### 可迁移的设计模式

```
模式名称：【_____________】

本质原理：________________________

OpenClaw 实现：_______________

可迁移性：___ / ___ / ___ / ___
(技术适配 / 模式迁移 / 差距化 / 不适用)

我们的适配方式：________________
```

### 模式对比表

| 模式 | OpenClaw | DivineSense | 迁移方式 |
|:-----|:---------|:------------|:---------|
| 记忆管理 | 时间修剪 | 语义检索 | 差距化 |
| 可扩展性 | Plugin SDK | 工具接口 | 适配 |
| 路由机制 | 三层路由 | 已实现 | 已有 |

### 示例

```markdown
## 模式抽象

### 可迁移的设计模式

**模式名称**：【记忆成本管理】

**本质原理**：在有限资源下最大化信息保留价值

**OpenClaw 实现**：
- 基于时间的修剪（旧 = 低价值）
- 结构化摘要（保留关键信息）

**可迁移性**：⚠️ 差距化机会

**我们的适配方式**：
- 不用时间修剪（我们无 API 成本）
- 用语义相关性检索（本地向量搜索优势）
- 实现更智能的记忆分层
```

---

## 5. 战略建议

### 做什么（Do）

| 优先级 | 功能 | 理由 | 预估 |
|:------|:-----|:-----|:-----|
| P0 | ___ | 符合差异化优势 | 2周 |
| P1 | ___ | 用户强需求 | 1周 |

### 不做什么（Don't）

| 功能 | 为什么不做 |
|:-----|:----------|
| ___ | 不符合本地化定位 |
| ___ | 我们做没有优势 |

### 差距化（Differentiate）

| 维度 | OpenClaw | 我们的方案 |
|:-----|:---------|:----------|
| 成本 | 云端 API | 本地零成本 |
| 性能 | Node.js | Go 单二进制 |

### 示例

```markdown
## 战略建议

### 做什么（Do）

| 优先级 | 功能 | 理由 |
|:------|:-----|:-----|
| **P0** | 本地记忆索引优化 | 利用本地化优势，实现语义相关性检索 |
| **P1** | 工具接口标准化 | 简化扩展，保持轻量 |

### 不做什么（Don't）

| 功能 | 为什么不做 |
|:-----|:----------|
| **主动修剪对话** | 我们无 API 成本压力 |
| **多渠道集成** | 专注个人场景，非我们赛道 |

### 差距化

| 维度 | OpenClaw | 我们 |
|:-----|:---------|:-----|
| **记忆策略** | 时间修剪（旧 = 无用） | 语义检索（相关 = 有用） |
| **部署** | Node.js 云服务 | 单二进制本地 |
| **开发者** | Plugin 生态 | Geek Mode CLI |
```

---

## 6. 实施任务

> 注意：仅在确定战略方向后生成

### 高优先级（P0）

```yaml
任务: 本地记忆索引优化
目标: 实现语义相关性检索
差异点: 不复制时间修剪，专注本地优势
产出: #X
```

### 中优先级（P1）

```yaml
任务: 工具接口标准化
目标: 简化第三方工具集成
产出: #Y
```

---

## 附录：快速检查清单

### 分析完整性

```
□ 问题本质：我理解了用户真正想要的吗？
□ 价值溯源：我知道为什么它成功吗？
□ 模式抽象：我识别了可迁移的模式吗？
□ 创造性转化：我找到了更好的方式吗？
□ 差距化：这利用了我们的独特优势吗？
```

### 战略判断

```
□ 确认"做"：符合差异化 + 用户需求 + 我们优势
□ 确认"不做"：明确为什么不做的理由
□ 确认"差异化"：这让我们在哪些维度胜出
```

---

*模板版本: v2.3.0 | 使用：分析完成后填充*
