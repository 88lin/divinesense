# 人机协同实践记录：DivineSense Skills 方案设计

> **案例**：DivineSense CC Runner Skills 管理系统
> **时间**：2026-02-09
> **形式**：通过 `/idea-researcher` skill 进行协作

---

## 一、协作起点

### 1.1 触发方式

用户使用了 `/idea-researcher` skill，并传入需求：

> "cc runner 能否在启动cc时指定skill，以达成在web页面支持"/" 命令执行特定skill的效果"

### 1.2 Skill 的作用

`idea-researcher` skill 是一个创意调研助手，它会：
1. 理解用户需求
2. 进行技术调研
3. 生成规范的 GitHub Issue

**这决定了后续的协作模式**：用户提出需求，AI 通过 skill 返回完整方案。

---

## 二、协作过程还原

### 2.1 初始假设的打破

用户的原始问题基于一个**隐性假设**：
- 假设 Claude Code CLI 支持 `--skill` 参数来指定技能

**AI 的第一反应**：验证这个假设

通过查阅 CLI 帮助文档和实际测试，发现：
```bash
# CLI 没有 --skill 参数
$ claude --help | grep skill
# (无结果)

# 但有斜杠命令机制
$ claude "/commit -m 'test'"
# (可以执行)
```

**结论**：假设不成立，需要调整设计思路。

---

### 2.2 设计思路的调整

**原始思路**（用户最初的三阶段构想）：
```
./skills/ → ~/divinesense/skills/ → ~/.claude/skills/
```

**AI 提出的问题**：
1. 为什么要分三层？部署态和运行态分开有什么好处？
2. 谁是"用户"？部署者？C 端用户？

**用户的修正**：
- 取消中间层，用户技能直接维护在 `~/.claude/skills/`
- 出厂技能首次启动时复制过去
- "用户"指 DivineSense 的部署者，不是 C 端使用者

---

### 2.3 关键质疑：一致性检查

**用户提出的问题**：
> "有一个关键点 Claude Code CLI 前面调研中，不是不支持 --skill 指令么？"

这个问题非常关键 —— 用户发现了 AI 方案中的**不一致性**。

**AI 的自我检查**：
- Issue 初稿中确实没有清晰说明"如何指定 skill"
- 需要明确：是通过构造 `/commit -m "msg"` 这样的 prompt 来实现

**修正后的方案**：
```go
// 不是用 CLI 参数指定 skill
// 而是构造斜杠命令作为 prompt
prompt := fmt.Sprintf("/%s %s", skillName, args)
r.Execute(ctx, cfg, prompt, callback)
```

---

### 2.4 Docker 目录的细节修正

**用户的发现**：
```
❌ ~/divinesense/
✅ ~/.divinesense/
```

这是一个**细节问题**，但很重要 —— Unix 约定配置目录通常以 `.` 开头（隐藏目录）。

**教训**：技术方案中的路径、命名等细节需要准确。

---

## 三、最终产出

### 3.1 GitHub Issue #127

协作产出了一个完整的技术方案 Issue，包含：

| 部分 | 内容 |
|:-----|:-----|
| 问题描述 | 需要实现的功能 |
| 调研结论 | CLI 机制的验证结果 |
| 解决方案 | 后端/前端/Docker 的完整设计 |
| 目录结构 | 开发态/部署态/运行态 |
| 版本管理 | 如何检测和更新出厂技能 |
| 验收标准 | 可测试的完成条件 |

### 3.2 技术方案核心点

1. **Skill Scanner**：扫描 `~/.claude/skills/`，解析 YAML frontmatter
2. **Skill Service**：提供 API 获取技能列表
3. **Skill Updater**：版本比较和更新提示
4. **前端组件**：`/` 命令输入和自动补全
5. **执行机制**：构造斜杠命令 prompt，由 CC Runner 发送给 CLI

---

## 四、经验总结（事实版本）

### 4.1 有用的模式

| 模式 | 说明 | 案例 |
|:-----|:-----|:-----|
| **验证优先** | 假设必须验证 | CLI 是否支持 `--skill` |
| **质疑简化** | 对复杂设计提出疑问 | 三层目录是否必要 |
| **一致性检查** | 方案与调研必须一致 | 斜杠命令机制贯穿全文 |
| **细节确认** | 路径、命名等要准确 | `.divinesense` vs `divinesense` |

### 4.2 协作中的关键节点

1. **假设验证**：第一件事就是验证用户的隐性假设
2. **方案简化**：通过提问减少不必要的复杂性
3. **一致性保证**：用户发现不一致，AI 修正方案
4. **细节打磨**：路径、命名等小问题也需要确认

### 4.3 Skill 的价值

使用 `/idea-researcher` skill 的好处：
- **结构化输出**：自动生成标准格式的 GitHub Issue
- **完整覆盖**：从调研到方案到验收标准
- **可追溯性**：每个结论有验证依据

---

## 五、给团队的建议

### 5.1 对用户（需求方）

1. **不要怕质疑**：发现不一致的地方立即提出
2. **明确角色**：说清楚"用户"是谁
3. **关注细节**：路径、命名等很重要

### 5.2 对 AI（实现方）

1. **验证假设**：不要基于假设设计
2. **主动简化**：对复杂设计提出疑问
3. **确保一致**：方案与调研结论必须一致

### 5.3 协作流程

```
需求提出 → 假设验证 → 方案设计 → 用户质疑 → 方案修正 → 最终确认
    ↑                                                      ↓
    └──────────────── 必要时重复───────────────────────────┘
```

---

## 六、附录：Issue 模板参考

### 6.1 技术调研模板

```markdown
### 调研结论

**假设**：
- 原始假设是什么

**验证方法**：
- 如何验证（命令/文档/代码）

**发现**：
- 实际机制是什么
- 与假设的差异

**证据**：
- 测试输出/文档引用
```

### 6.2 方案设计模板

```markdown
### 解决方案

**功能范围**
- 包含：✅ ...
- 不包含：❌ ...

**技术方案**
- 后端组件：...
- 前端组件：...
- 目录结构：...

**验收标准**
- [ ] 可测试的标准
```

---

*文档版本：v2.0（事实修正版）*
*创建日期：2026-02-09*
